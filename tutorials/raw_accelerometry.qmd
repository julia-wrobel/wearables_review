---
title: "Raw Accelerometry Tutorial"
date: "`r Sys.Date()`"
format: 
  html:
    toc: true
    toc-location: left
    embed-resources: true
    code-background: true
    code-tools: true
    code-fold: false
    code-block-border-left: true
    theme: flatly
execute:
  echo: true
  cache: true
  message: false
  warning: false
editor: source
---

```{r load packages} 
library(dplyr)
library(ggplot2)
library(tidyr)
library(lubridate)
```

Here we'll focus on downloading and processing a `gt3x` file. This file format is used by ActiGraph accelerometers, and it contains raw accelerometer data along with metadata such as timestamps and device information. Accelerometry data may be provided in many formats, but will typically include timestamps and values for acceleration in the X, Y, and Z dimensions. 


First, we download a gt3x file from the [ActiGraph website](https://actigraphcorp.my.site.com/support/s/article/GT3X-ActiSleep-Sample-Data).

## Download file 

```{r download data}
gt3x_file = here::here("data", "accel_data_raw", "GT3X+ (01 day).gt3x")

if(!file.exists(gt3x_file)){
  url = "http://dl.theactigraph.com/demo/files/GT3XPlus-RawData(1-20).zip"

  out_file = here::here("data", "accel_data_raw.zip")
  if(!file.exists(out_file)){
    curl::curl_download(url, out_file, mode = "wb")
  }
  
  zip_file = here::here("data", "accel_data_raw.zip")
  out_dir  = here::here("data", "accel_data_raw")
  
  if (!dir.exists(out_dir)) {
    dir.create(out_dir, recursive = TRUE)
  }
  
  zip_list = unzip(zip_file, list = TRUE)
  
  unzip(zip_file, files = zip_list[1]$Name, exdir = out_dir)
}

```

## Read in the data 

We read in the data using the `read.gt3x` package. We read in as a dataframe instead of matrix (`asDataFrame = TRUE`) and impute any missing values with zeroes (`imputeZeroes = TRUE`).  The `read.gt3x` function will read in the data and return a `data.frame` with columns for time, X, Y, Z, and other metadata.  The time column is in POSIXct format.



```{r read in gt3x}
#| cache: true

df = read.gt3x::read.gt3x(path = gt3x_file,
                          asDataFrame = TRUE,
                          imputeZeroes = TRUE)

```
## Get to know the data

We can examine the data: we see columns for time, X, Y, and Z, in addition to information on the sampling rate, firmware, and serial number. 

```{r}
head(df)
```

The data frame also has atributes that provide additional information about the data, such as the sampling rate and device information. 

```{r}
attributes(df) %>% names
attr(df, "sample_rate")

```

### A note on timestamps 

When working with sub-second level data, make sure to set option `digits.secs = 3`. This option allows users to see quickly if the milliseconds are embedded or truncated. 

```{r}
options(digits.secs = 3)
head(as.data.frame(df), n = 3)
```


### A note on time zones 

When using `read.gt3x`, the time zone of the output data is always `GMT`. Which time zone the data were collected in is contained in the header: 

```{r}
attr_list = attributes(df)
attr_list$header$TimeZone
```
::: {.callout-note}
#### Note
All timestamps are in local time (of the device) even though they are represented as `POSIXct` with `GMT` timezone [in the data].
:::


You can set the data to the correct timezone with `lubridate::tz`. The `with_tz` and `force_tz` functions may be useful can change the timestamp the data in different ways (changing attribute vs. changing data).  

### Helpful lubridate functions 

The `lubridate` package provides many useful functions for working with dates and times. Here are a few that may be helpful when working with accelerometry data. 


#### Rounding datetimes

```{r}
df %>% 
  mutate(min_30 = lubridate::floor_date(time, unit = "30 minutes")) %>% 
  head()

```
`floor_date` is especially powerful when combined with `group_by` to summarize by a time window: 

```{r}
df %>% 
  mutate(min_30 = lubridate::floor_date(time, unit = "30 minutes")) %>% 
  group_by(min_30) %>% 
  summarise(across(c(X, Y, Z), mean))


```
#### Manipulating time zones 

We can add the timezone `America/Los_Angeles` to the data.  We can take a simple set of times from our data and show the timezone using `tz`: 

```{r}
times = head(df$time)
times
tz(times)
```

The `force_tz`, and  `tz(x) <-` functions assign a specified timezone to the object.

```{r}
times_pst = times; tz(times_pst) <- "America/Los_Angeles"; times_pst
force_tz(times, "America/Los_Angeles")
```

Note the data still indicates hour `10:00`, but in a different timezone, indicating a different time being measured. 

The `with_tz` function projects the data into a timezone, but the actual moment of time does not change:

```{r}
with_tz(times, "America/Los_Angeles")
```

Note the data displays hour `03:00` as this shifts the data from GMT.  We can see that `force_tz` doesn't change the way the data is stored, just the way it is displayed, but `with_tz` changes the way the data is both stored and displayed.

```{r}
as.numeric(times_pst)
as.numeric(force_tz(times, "America/Los_Angeles"))
as.numeric(with_tz(times, "America/Los_Angeles"))
```

:::{.callout-warning}
#### Warning
Use caution with time zones, especially in the presence of data from different devices and when merging data with timestamps, such as merging with GPS or heart rate data. Shifting time may project some data into a different day/date, which is highly relevant since many summary measures are done at a day/date level.

:::

## Plotting the data 


Before we do anything else, let's plot the data. We have `r nrow(df)` observations, so we'll want to start with plotting a subset only. We pivot the data longer for easier plotting. 

```{r}
#| cache: true 
long = df %>% 
  pivot_longer(cols = X:Z, names_to = "axis", values_to = "accel")

long %>% 
  filter(between(time, floor_date(time[1]), #keep only first 5 minutes
                   floor_date(time[1]) + as.period(5, "minutes"))) %>% 
    ggplot(aes(x = time, y = accel, colour = axis)) + 
    geom_rect(aes(xmin = time[1], # plot the pink rectangle
                  xmax = ymd_hms("2012-06-27 10:54:04.666"),
                  ymin = -Inf,
                  ymax = Inf), fill = 'pink', alpha = 0.05, color = NA) + # make transparent
    geom_line() + # add acceleration, can also do `geom_step`
    theme(legend.position = "inside", 
          legend.position.inside = c(0.6, 0.78)) +
  guides(color = guide_legend(nrow = 1)) +
    scale_color_brewer(palette = "Dark2",name = "Axis") +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "1 min")+
  labs(y = "Acceleration (g)", x = "Time")


# df %>% 
#   filter(between(time, time_start, time_start + as.period(60, "minute"))) %>% 
#   pivot_longer(cols = X:Z) %>% 
#   ggplot(aes(x = time, y = value, color = name)) +
#   geom_line() +
#   scale_color_brewer(palette = "Dark2", name = "Dimension") + 
#   labs(x = "Time of Day", y = "Acceleration (g)") + 
#   theme_light()
# 
# time_start = as.POSIXct("2012-06-27 18:00", tz = "GMT")
# df %>% 
#   filter(between(time, time_start, time_start + as.period(60, "minute"))) %>% 
#   pivot_longer(cols = X:Z) %>% 
#   ggplot(aes(x = time, y = value, color = name)) +
#   geom_line() +
#   scale_color_brewer(palette = "Dark2", name = "Dimension") + 
#   labs(x = "Time of Day", y = "Acceleration (g)") + 
#   theme_light()


```
We see that at the beginning of the data, all acceleration values are zero. We'll discuss this in the context of idle sleep mode. 


## Idle sleep mode 

In idle sleep mode, data are missing. Options for handling idle sleep mode are  1) have gaps in the data, 2) fill in `NA` values for these segments, 3) fill in `0` values for these segments, or 4) last observation carried forward (LOCF).  The LOCF approach is such that if the last measurement before non-measurement on an axis was `0.952` for example, the value of `0.952` will be repeated for each sample until the device moves. Each axis is handled separately (no information for X is used for Y). This procedure is done for all axes.  

The issues with each approach, respectively, are:  

1. gaps: most software assumes continuous/contiguous time and users cannot specify missing segments with some software as time is not even passed, but simply the measurements, 
2. `NA` fill-in: some software assumes no missing data and some temporal filtering operations may fail or give surprising results with `NA` values.
3. `0` fill in: somewhat inappropriate since at least gravity is being exerted on the device, can cause sharp changes in the signal that may change results, which can induce higher variance than is correct (going from value to `0`), also some interpolation will push values to the opposite sign (negative before 0, then 0, then positive interpolated)
4. LOCF: not accurate or "real" values and harder to identify non-wear after the fact if not flagged appropriately as the device is not moving.

This LOCF approach, however, is consistent with the ActiGraph documentation, induces a variance of 0 during this time interval, has no jump discontinuity from previous measurements, provides continuous signal, and can be flagged.  Also, summary measures of activity (e.g. Activity Counts, Activity Index) should provide an appropriate summary value of $0$ to this zero variance data.

The `flag_idle_sleep` (default `FALSE`) argument in `read.gt3x` can also output a column of samples with an indicator of `idle` or not:

```{r read_flagged_data}
df_flagged = read.gt3x::read.gt3x(path = gt3x_file, 
                                  asDataFrame = TRUE, 
                                  imputeZeroes = TRUE,
                                  flag_idle_sleep = TRUE)
head(df_flagged)
```


Not all zeroes are idle sleep mode events, but usually are handled similarly with LOCF due to the discussion above.

There are packages that implement LOCF on this type of data, but we can also do it using some straightforward functions in the `tidyverse`.  Namely, we will find records where all axes have an acceleration of $0$, replace those acceleration values for those records with `NA` and fill in the data (using LOCF) using `tidyr::fill` [@tidyr].

```{r save_xdf}
#| echo: false
xdf = df
```

```{r fill_data}
sample_rate = attr(df, "sample_rate")
acceleration_max = as.numeric(attr(df, "acceleration_max"))
df = dplyr::as_tibble(df)
df = df %>% 
  mutate(all_zero = X == 0 & Y == 0 & Z == 0) %>%  # flag where all zeroes
  
  mutate( # replace all 0 with NA so it can be filled  
    X = ifelse(all_zero, NA_real_, X),
    Y = ifelse(all_zero, NA_real_, Y),
    Z = ifelse(all_zero, NA_real_, Z)
  )
any(df$all_zero)
df = df %>% 
  select(-all_zero) %>% # remove this column
  tidyr::fill(X, Y, Z, .direction = "down") # fill down using LOCF (time sorted)
head(df)
```

Although not present in this data, if the first records are in idle sleep mode, they will have no "before value" to fill in and will continue to be `NA` given this code.  To handle this last case we can replace these values using `tidyr::fill` with the direction of "up" to make a flat starting signal or with $0$ for simplicity (done here):

```{r na_replace}
df = df %>% tidyr::replace_na(list(X = 0, Y = 0, Z = 0))
```

This ensures that every record has a numeric value.  Users can also drop those first records.

Now we can see that the signal has been filled in for those segments that were previously all $0$.


```{r}
long = df %>% 
  pivot_longer(cols = X:Z, names_to = "axis", values_to = "accel")

long %>% 
  filter(between(time, floor_date(time[1]), #keep only first 5 minutes
                   floor_date(time[1]) + as.period(5, "minutes"))) %>% 
    ggplot(aes(x = time, y = accel, colour = axis)) + 
    geom_rect(aes(xmin = time[1], # plot the pink rectangle
                  xmax = ymd_hms("2012-06-27 10:54:04.666"),
                  ymin = -Inf,
                  ymax = Inf), fill = 'pink', alpha = 0.05, color = NA) + # make transparent
    geom_line() + # add acceleration, can also do `geom_step`
    theme(legend.position = "inside", 
          legend.position.inside = c(0.6, 0.78)) +
  guides(color = guide_legend(nrow = 1)) +
    scale_color_brewer(palette = "Dark2",name = "Axis") +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "1 min")+
  labs(y = "Acceleration (g)", x = "Time")

```

## Gravity Calibration

## Nonwear detection 

## Sleep detection ?

## Resampling 

## Temporal Filtering 

